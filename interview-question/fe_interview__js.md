# 一、前言
## 1、高阶函数 & 函数抽象
```js
重点
  1、重点关注js的原始类型和引用类型、思考此设计影响的浅拷贝/深拷贝，可变性/不可变性的概念；
  2、理解纯函数、高阶函数、函数复用的相关知识、DRY、提升代码复用率
应用
  1、shallow Copy => React 性能优化
  2、Compose => Redux Middleware
```
## 2、异步编程
```js
重点：
  1、思考和理解EventLoop中操作的执行顺序，特别是宏队列和微任务的执行顺序
  2、理解处理异步操作的演变历史，以及Promise、Async/Await的原理

应用：
 1、MircoTasks => Vue.$nextTick()
 2、单线程 => Vue 依赖跟踪
```
## 3、js设计模式
```js
重点
  1、理解各个设计模式的使用场景
  2、对相似的模式（如观察者模式、订阅发布模式、中介者模式）能理解异同点，打好基础！
应用
  1、订阅发布模式 => Vuex
  2、中间件模式 => Koa
```

# 二、函数
## 1、js内存管理
### 1）内存机制
```js
内存空间：栈内存(stack):先进后出，堆内存(heap): 先进先出
疑问：
  1、执行语句也在哪里？是怎样的一个过程？
  2、栈、堆的比较
```
### 2）垃圾回收
#### (1) 概念：平时我们创建的所有数据都需要内容，而垃圾回收，就是我们不再使用的数据，清理掉，释放其战友的内存；垃圾回收会按照时间间隔周期性的执行这一操作。
#### (2) js使用的垃圾回收机制来自动管理内存，垃圾回收是把双刃刀，垃圾回收是不可见的。
- 优势：可以大幅度简化程序的内存管理代码，降低程序员的负担，减少因长时间运作而带来的内存泄露问题。
- 不足：程序员无法掌控，js没有暴露出任何关于内存的api，无法强迫进行垃圾回收，无法干预内存管理。
#### (3) 垃圾回收的方式
- 引用计数
- 标记清除（现代浏览器常用的方式）
```js
概念：
  标记清除是当变量进入环境的时候，将该变量标记为"进入环境"，当变量离开时，则标记为"离开环境"，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并收回它们所占用的内存空间。

全局执行环境：
 - 最外围的执行环境
 - 根据宿主环境的不同表示的执行环境的对象也不一样，在浏览器中全局执行环境被认为是window对象
 - 全局变量和函数都是作为window对象的属性和方法创建的
 - 某个执行环境的所有低吗执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境只有关闭网页的时候才会被销毁）

 环境栈：
 - 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境，ECMascript程序中的执行流正是由这个方便的机制控制着。
```
### 3）V8内存管理机制
#### (1) V8引擎限制内存的原因
- V8最初为浏览器设计，不太可能遇到大量内存的使用场景
- 防止因为垃圾回收所导致的线程暂停时间过长
#### (2) V8回收策略
- v8采用一种分代回收的策略，将内存分为两个生代；新生代和老生代
- v8分别对新生代和老生代使用不同的回收算法来提升垃圾回收效率
#### (3) 新生代垃圾回收
- from和to组成一个semispace, 回收的时候将要回收的放置于to空间，from空间则留下不被释放的对象
#### (4) 新生代的晋级（新生代中用来存放生命较短的对象，老生代中存放生命较长的对象）
- 在新生代回收中，当一个对象经过多次复制后依然存活，它将会被认为时生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理。
- 在From空间和to空间进行反转的过程中，如果to空间中使用的量已经超过了25%，那么将from中的对象直接晋级到老生代内存空间中
#### (5) 老生代垃圾回收
- 老生代内存空间是一个连续的机构
- 标记清除
- 标记合并

## 2、如何保证你的代码质量
### 1）单元测试
#### (1) 概念
- 测试是一种验证我们的代码是否可以按期工作的方法
- 单元测试是对软件中最小可测试单元进行检测和验证
#### (2) 前端单元测试的意义
- 检测出潜在的bug
- 快速反馈功能输出，验证代码是否可达到预期
- 保证代码重构的安全性
- 方便协作开发
### 2）jset的基础使用（facebook 的一套测试js框架）

## 3、提高代码的可靠性
### 1）函数式编程(+2)
#### 含义：是一种编程范式，将逻辑写入函数中，定义好输入，只关心输出。另外，编程范式大概分为：命令式编程、声明式编程、函数式编程。
### 2）纯函数： 无状态+数据不可变，即相同的输入，必定返回相同的输出。（+2）
### 3）函数副作用
```js
函数副作用是指当调用函数时，除了返回函数值之外，还对主函数产生附加影响，比如
- 修改了一个变量
- 直接修改数据结构
- 设置了一个对象的成员
- 抛出一个异常或以一个错误终止
- 打印到终端或读取用户输入
- 读取或写入一个文件
- 在屏幕上画图
```

# 三、异步编程
## 1、理解异步：异步、同步
### 1）浏览器的进程
  - 浏览器进程
  - 渲染进程
    - GUI线程
    - JS引擎线程
    - 定时器触发线程
    - 事件触发线程
    - 异步HTTP请求线程
  - GPU进程
  - 网络进程
  - 插件进程
### 2）宏任务、微任务
#### (1) 宏任务
- script
- setImediate
- setTimeiout 和 setInterval
- requestAnimationFrame
- I/O
- UI rendering
#### (2) 微任务
- Object.observer：监听对象变化的一个方法
- MutationObserver: 可以监听Dom结构变化的一个api
- postMessage:window对象通信的一个方法
- pormise.then .catch .finally
## 2、Event Loop机制
## 3、异步编程方法-发布/订阅
### 1）异步编程的几种方式
- 回调函数
- 事件发布/订阅
- Promise
- generator函数
- aysnc函数
### 2) 实现事件发布/订阅
```js
class PubSub {
  constructor() {
    this.events = {}
  }
  // 发布
  publish(eventName, data) {
    if(this.events[eventName]) {
      this.events[eventName].forEach(cb => {
        cb.apply(this, data)
      })
    }
  }
  // 订阅
  subscribe(eventName, callback) {
    if(this.events[eventName]) {
      this.events[eventName].push(callbacks)
    }else {
      this.events[eventName] = [callback]
    }
  }
  // 取消订阅
  unSubscribe(eventName, callback) {
    if(this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback)
    }
  }
}
```
## 4、**深入理解Promise**
## 5、**Generator函数及其异步的应用**
## 6、**深入理解async/await**
## 7、**手写Promise**
## 8、Web Workers的多线程机制
### 1）web Workers的介绍
- 一个web Api -> 浏览器能力 -> 提供一个js可以运行的环境
- web应用程序可以在独立于主线程的后台线程中，运行一个脚本操作
- 关键点：性能考虑
### 2）worker的主要方法
- onerror, onmessage, onmessageerror, postMessage, importScripts, close
### 3）worker的能力是受限的
- 与主线程脚本同源：在主线程运行的worker必须与主线程同源
- 与主线程上下文不同：
  - 在worker下无法操作dom，可以操作Navigator, location等，就是不会引起页面混乱的可以用
  - 不能执行alert
- 不能读取本地文件
  - 所有加载的文件来源于网络，不来源于file协议
### 4）web worker的使用场景
- 解决痛点
  - js执行复杂运行时阻塞页面渲染
- 使用场景
  - 复杂运算
  - 渲染优化(canvas有个离线的api结合worker)
  - 流媒体数据处理
- 哪些项目用到了web worker
  - flv.js

## 9、Service Worker（离线体验）
### 1）初识Service Worker
Service Worker的本质充当Web应用程序、浏览器与网络之间的代理服务器，这个API旨在创建有效的离线体验，他会拦截网络请求并根据网络是否可用来采取适当的动作，更新来自服务器的资源，它还提供入口推送通知来访问后台同步API。
- 网站必须使用https,除了本地开发环境（localhost)
- 运行于浏览器，可以控制打开的作用域范围下所有的页面请求，可拦截请求和返回，缓存文件；sw可通过fetch这个api，来拦截网络或处理网络请求，在配合cacheStorage来实现web页面的缓存管理以及前端postMessage通信
- 单独的作用域范围，单独的运行环境和执行环境
- 不能操作页面DOMM，可以通过事件机制来处理
- 完全异步，同步API（如xhr和localStorage)不能再service worker中使用，sw大量使用promise
- 一旦被install，就永远存在，除非被uninstall或者dev模式手动删除
- 响应推送
- serveice worker是事件驱动的worker，生命周期与页面无关。关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动。
### 2）service worker的生命周期
- installing
- install
- activating
- activated
- redunant

### 3）service worker的优势
- 支持离线访问
- 加载速度快
- 离线状态下的可用性
### 4）service worker的安全策略
- 使用https或者localhost才能使用service worker
- service worker都有一个有限的控制范围，这个范围通过放置service worker的js文件的目录决定的，也就是service worker所在目录以及所有的子目录。

# 四、设计模式
## 1、设计模式概论
### 1）设计原则
- 开闭原则:对扩展开发，对修改关闭
- 单一职责原则
- 依赖倒置原则： 我们的上层模块不要依赖于具体的下层模块，应该依赖于抽象模块
- 接口隔离原则
- 迪米特法则
- 里氏替换原则
### 2）设计模式分类
- 创建型
  - 工厂模式
  - 单例模式
  - 建造者模式
  - 原型模式
- 结构型
  - 外观模式
  - 适配器模式
  - 装饰者模式
  - 享元模式
  - 桥接模式
- 行为型
  - 观察者模式
  - 状态模式
  - 职责链模式
  - 命令模式
  - 迭代器模式
- 技巧型
  - 链模式
  - 委托模式
  - 数据访问模式
  - 惰性模式
  - 等待者模式

## 2、封装对象
- 定义的变量不会污染到外部
- 能够作为一个模块调用
- 遵循开闭原则
- 变量外部不可见
- 调用接口使用
- 留出扩展接口
### 1）封装对象时的设计模式



